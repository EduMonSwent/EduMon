package com.android.sample.ui.flashcards

import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.android.sample.ui.flashcards.data.FirestoreFlashcardsRepository
import com.android.sample.ui.flashcards.model.Flashcard
import com.android.sample.util.FirebaseEmulator
import com.google.android.gms.tasks.Tasks
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.DocumentSnapshot
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

/**
 * End-to-end emulator tests for FirestoreFlashcardsRepository. Uses real FirebaseAuth + Firestore
 * connected to the local emulator. Parts of this code have been generated by an AI.
 */
@RunWith(AndroidJUnit4::class)
class FirestoreFlashcardsRepositoryEmulatorTest {

  private lateinit var db: FirebaseFirestore
  private lateinit var auth: FirebaseAuth
  private lateinit var repo: FirestoreFlashcardsRepository

  @Before
  fun setUp() = runBlocking {
    // ---- connect to emulators just like the Weeks test ----
    FirebaseEmulator.initIfNeeded(ApplicationProvider.getApplicationContext())
    FirebaseEmulator.connectIfRunning()

    assertTrue(
        "Firebase emulators not reachable (firestore:8080, auth:9099). " +
            "Start with: firebase emulators:start --only firestore,auth",
        FirebaseEmulator.isRunning)

    FirebaseEmulator.clearAll()
    Tasks.await(FirebaseEmulator.auth.signInAnonymously())

    db = FirebaseEmulator.firestore
    auth = FirebaseEmulator.auth
    repo = FirestoreFlashcardsRepository(db, auth)
  }

  @After
  fun tearDown() = runBlocking { if (FirebaseEmulator.isRunning) FirebaseEmulator.clearAll() }

  // ---------- helpers ----------

  private suspend fun currentUid(): String = Tasks.await(auth.signInAnonymously()).user!!.uid

  private suspend fun readDeckDoc(uid: String, deckId: String): DocumentSnapshot? {
    val snap =
        Tasks.await(db.collection("users").document(uid).collection("decks").document(deckId).get())
    return if (snap.exists()) snap else null
  }

  // ---------- tests ----------

  @Test
  fun observeDeck_updates_after_addCard() = runBlocking {
    val deckId = repo.createDeck("Spanish", "Basics", emptyList())

    val initial = repo.observeDeck(deckId).first()
    assertTrue(initial!!.cards.isEmpty())

    repo.addCard(deckId, Flashcard(question = "Hola", answer = "Hello"))
    delay(200)

    val updated = repo.observeDeck(deckId).first()
    assertTrue(updated!!.cards.any { it.question == "Hola" && it.answer == "Hello" })
  }

  @Test
  fun addCard_ignores_blank_question_or_answer() = runBlocking {
    val deckId = repo.createDeck("Math", "Algebra", emptyList())

    repo.addCard(deckId, Flashcard(question = "", answer = "A"))
    repo.addCard(deckId, Flashcard(question = "Q", answer = ""))

    delay(200)
    val snapshot = repo.observeDeck(deckId).first()
    assertTrue(snapshot!!.cards.isEmpty())
  }

  @Test
  fun deleteDeck_removes_cards_and_deck() = runBlocking {
    val uid = currentUid()
    val deckId =
        repo.createDeck(
            "German", "Basics", listOf(Flashcard(question = "Danke", answer = "Thanks")))

    assertNotNull(readDeckDoc(uid, deckId))

    repo.deleteDeck(deckId)
    delay(200)

    val gone = repo.observeDeck(deckId).first()
    assertNull(gone)
    assertNull(readDeckDoc(uid, deckId))
  }

  @Test
  fun deleteDeck_handles_multiple_batches() = runBlocking {
    val uid = currentUid()
    val deckId = repo.createDeck("Big deck", "Lots of cards", emptyList())

    repeat(900) { i -> repo.addCard(deckId, Flashcard(question = "Q$i", answer = "A$i")) }
    delay(1000)

    repo.deleteDeck(deckId)
    delay(300)

    assertNull(readDeckDoc(uid, deckId))
  }

  @Test
  fun addCard_updates_deck_updatedAt() = runBlocking {
    val uid = currentUid()
    val deckId = repo.createDeck("Chemistry", "Atoms", emptyList())

    val before = readDeckDoc(uid, deckId)!!.getTimestamp("updatedAt")!!
    delay(50)
    repo.addCard(deckId, Flashcard(question = "H2O", answer = "Water"))
    delay(200)
    val after = readDeckDoc(uid, deckId)!!.getTimestamp("updatedAt")!!

    assertTrue(!after.toDate().before(before.toDate()))
  }

  @Test
  fun unsigned_behaviour_is_safe() = runBlocking {
    // Simulate no user by signing out
    FirebaseEmulator.auth.signOut()
    val unsignedRepo = FirestoreFlashcardsRepository(db, auth)

    val list = unsignedRepo.observeDecks().first()
    assertTrue(list.isEmpty())

    val one = unsignedRepo.observeDeck("any").first()
    assertNull(one)

    val id = unsignedRepo.createDeck("Bio", "Cells", emptyList())
    assertTrue(id.isNotBlank())

    unsignedRepo.addCard("fake", Flashcard(question = "Q", answer = "A"))
    unsignedRepo.deleteDeck("fake")
  }

  // ---------- TESTS FOR IMPORT FEATURE ----------

  @Test
  fun createShareToken_createsSharedDeckDocument() = runBlocking {
    val ownerUid = currentUid()
    val deckId = repo.createDeck("Physics", "Mechanics", emptyList())

    val token = repo.createShareToken(deckId)
    assertTrue(token.isNotBlank())

    val sharedDoc = Tasks.await(db.collection("sharedDecks").document(token).get())
    assertTrue(sharedDoc.exists())
    assertEquals(ownerUid, sharedDoc.getString("ownerId"))
    assertEquals(deckId, sharedDoc.getString("deckId"))
  }

  @Test
  fun importSharedDeck_invalidToken_returnsBlank() = runBlocking {
    val result = repo.importSharedDeck("does-not-exist")
    assertTrue(result.isBlank())
  }

  @Test
  fun importSharedDeck_copiesDeckAndCardsForNewUser() = runBlocking {
    // Owner creates deck and share token
    val ownerUid = currentUid()
    val deckId =
        repo.createDeck(
            "Biology",
            "Plants",
            listOf(
                Flashcard(question = "Leaf", answer = "Photosynthesis"),
                Flashcard(question = "Root", answer = "Absorption")))
    val token = repo.createShareToken(deckId)

    // Switch to a fresh anonymous user (emulator creates new uid)
    val newUserUid = currentUid()

    val importedId = repo.importSharedDeck(token)
    assertTrue(importedId.isNotBlank())

    // Read imported deck under new user
    val importedDeckDoc = readDeckDoc(newUserUid, importedId)
    assertNotNull(importedDeckDoc)

    val cardsSnap =
        Tasks.await(
            db.collection("users")
                .document(newUserUid)
                .collection("decks")
                .document(importedId)
                .collection("cards")
                .get())
    assertEquals(2, cardsSnap.size())
  }

  @Test
  fun importSharedDeck_setsShareableFalse_andDifferentId() = runBlocking {
    val originalId = repo.createDeck("Chemistry", "Organic", emptyList())
    val token = repo.createShareToken(originalId)

    // new user
    val newUserUid = currentUid()

    val importedId = repo.importSharedDeck(token)
    assertTrue(importedId.isNotBlank())
    assertNotEquals(originalId, importedId)

    val importedDoc = readDeckDoc(newUserUid, importedId)!!
    assertEquals(false, importedDoc.getBoolean("shareable"))
    assertEquals(importedId, importedDoc.getString("id"))
  }

  @Test
  fun setDeckShareable_updatesShareableFieldInFirestore() = runBlocking {
    val uid = currentUid()

    // 1) Create deck (shareable is false by default)
    val deckId =
        repo.createDeck(
            "Physics", "Quantum", listOf(Flashcard(question = "Photon", answer = "Light particle")))
    delay(200)

    // Read initial state
    val before = readDeckDoc(uid, deckId)
    assertNotNull(before)
    assertEquals(false, before!!.getBoolean("shareable"))

    // 2) Set shareable = true
    repo.setDeckShareable(deckId, true)
    delay(200)

    val afterTrue = readDeckDoc(uid, deckId)
    assertNotNull(afterTrue)
    assertEquals(true, afterTrue!!.getBoolean("shareable"))

    // 3) Set shareable = false
    repo.setDeckShareable(deckId, false)
    delay(200)

    val afterFalse = readDeckDoc(uid, deckId)
    assertNotNull(afterFalse)
    assertEquals(false, afterFalse!!.getBoolean("shareable"))
  }
}
