package com.android.sample.ui.flashcards

import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.android.sample.ui.flashcards.data.FirestoreFlashcardsRepository
import com.android.sample.ui.flashcards.data.FlashcardsRepository
import com.android.sample.ui.flashcards.model.Flashcard
import com.android.sample.util.FirebaseEmulator
import com.google.android.gms.tasks.Tasks
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.DocumentSnapshot
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

/**
 * End-to-end emulator tests for FirestoreFlashcardsRepository. Uses real FirebaseAuth + Firestore
 * connected to the local emulator. Parts of this code have been generated by an AI.
 */
@RunWith(AndroidJUnit4::class)
class FirestoreFlashcardsRepositoryEmulatorTest {

  private lateinit var db: FirebaseFirestore
  private lateinit var auth: FirebaseAuth
  private lateinit var repo: FlashcardsRepository

  @Before
  fun setUp() = runBlocking {
    // ---- connect to emulators just like the Weeks test ----
    FirebaseEmulator.initIfNeeded(ApplicationProvider.getApplicationContext())
    FirebaseEmulator.connectIfRunning()

    assertTrue(
        "Firebase emulators not reachable (firestore:8080, auth:9099). " +
            "Start with: firebase emulators:start --only firestore,auth",
        FirebaseEmulator.isRunning)

    FirebaseEmulator.clearAll()
    Tasks.await(FirebaseEmulator.auth.signInAnonymously())

    db = FirebaseEmulator.firestore
    auth = FirebaseEmulator.auth
    repo = FirestoreFlashcardsRepository(db, auth)
  }

  @After
  fun tearDown() = runBlocking { if (FirebaseEmulator.isRunning) FirebaseEmulator.clearAll() }

  // ---------- helpers ----------

  private suspend fun currentUid(): String = Tasks.await(auth.signInAnonymously()).user!!.uid

  private suspend fun readDeckDoc(uid: String, deckId: String): DocumentSnapshot? {
    val snap =
        Tasks.await(db.collection("users").document(uid).collection("decks").document(deckId).get())
    return if (snap.exists()) snap else null
  }

  // ---------- tests ----------

  @Test
  fun observeDeck_updates_after_addCard() = runBlocking {
    val deckId = repo.createDeck("Spanish", "Basics", emptyList())

    val initial = repo.observeDeck(deckId).first()
    assertTrue(initial!!.cards.isEmpty())

    repo.addCard(deckId, Flashcard(question = "Hola", answer = "Hello"))
    delay(200)

    val updated = repo.observeDeck(deckId).first()
    assertTrue(updated!!.cards.any { it.question == "Hola" && it.answer == "Hello" })
  }

  @Test
  fun addCard_ignores_blank_question_or_answer() = runBlocking {
    val deckId = repo.createDeck("Math", "Algebra", emptyList())

    repo.addCard(deckId, Flashcard(question = "", answer = "A"))
    repo.addCard(deckId, Flashcard(question = "Q", answer = ""))

    delay(200)
    val snapshot = repo.observeDeck(deckId).first()
    assertTrue(snapshot!!.cards.isEmpty())
  }

  @Test
  fun deleteDeck_removes_cards_and_deck() = runBlocking {
    val uid = currentUid()
    val deckId =
        repo.createDeck(
            "German", "Basics", listOf(Flashcard(question = "Danke", answer = "Thanks")))

    assertNotNull(readDeckDoc(uid, deckId))

    repo.deleteDeck(deckId)
    delay(200)

    val gone = repo.observeDeck(deckId).first()
    assertNull(gone)
    assertNull(readDeckDoc(uid, deckId))
  }

  @Test
  fun deleteDeck_handles_multiple_batches() = runBlocking {
    val uid = currentUid()
    val deckId = repo.createDeck("Big deck", "Lots of cards", emptyList())

    repeat(900) { i -> repo.addCard(deckId, Flashcard(question = "Q$i", answer = "A$i")) }
    delay(1000)

    repo.deleteDeck(deckId)
    delay(300)

    assertNull(readDeckDoc(uid, deckId))
  }

  @Test
  fun addCard_updates_deck_updatedAt() = runBlocking {
    val uid = currentUid()
    val deckId = repo.createDeck("Chemistry", "Atoms", emptyList())

    val before = readDeckDoc(uid, deckId)!!.getTimestamp("updatedAt")!!
    delay(50)
    repo.addCard(deckId, Flashcard(question = "H2O", answer = "Water"))
    delay(200)
    val after = readDeckDoc(uid, deckId)!!.getTimestamp("updatedAt")!!

    assertTrue(!after.toDate().before(before.toDate()))
  }

  @Test
  fun unsigned_behaviour_is_safe() = runBlocking {
    // Simulate no user by signing out
    FirebaseEmulator.auth.signOut()
    val unsignedRepo = FirestoreFlashcardsRepository(db, auth)

    val list = unsignedRepo.observeDecks().first()
    assertTrue(list.isEmpty())

    val one = unsignedRepo.observeDeck("any").first()
    assertNull(one)

    val id = unsignedRepo.createDeck("Bio", "Cells", emptyList())
    assertTrue(id.isNotBlank())

    unsignedRepo.addCard("fake", Flashcard(question = "Q", answer = "A"))
    unsignedRepo.deleteDeck("fake")
  }
}
