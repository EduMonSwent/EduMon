package com.android.sample.ui.flashcards

import androidx.activity.ComponentActivity
import androidx.compose.ui.test.assertIsDisplayed
import androidx.compose.ui.test.hasText
import androidx.compose.ui.test.junit4.AndroidComposeTestRule
import androidx.compose.ui.test.junit4.createAndroidComposeRule
import androidx.compose.ui.test.onNodeWithContentDescription
import androidx.compose.ui.test.onNodeWithTag
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.android.sample.repos_providors.FakeRepositories
import com.android.sample.ui.flashcards.data.FirestoreFlashcardsRepoProvider
import com.android.sample.ui.flashcards.model.Deck
import com.android.sample.ui.flashcards.model.Flashcard
import com.android.sample.ui.theme.EduMonTheme
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.tasks.await
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith

/**
 * Flashcards UI flow that does NOT touch MainActivity. It hosts FlashcardsApp directly and
 * pre-populates the repo to avoid performTextInput (works around Semantics getIsEditable crash).
 * Parts of this code have been generated by AI.
 */
@RunWith(AndroidJUnit4::class)
class FlashcardsFlowTest {

  @get:Rule val composeRule = createAndroidComposeRule<ComponentActivity>()

  // tiny helpers
  private fun AndroidComposeTestRule<*, *>.waitAndAssertVisible(
      text: String,
      timeoutMs: Long = 10_000
  ) {
    val m = hasText(text, substring = true, ignoreCase = true)
    waitUntil(timeoutMs) {
      onAllNodes(m, useUnmergedTree = true).fetchSemanticsNodes().isNotEmpty()
    }
    onNode(m, useUnmergedTree = true).assertIsDisplayed()
  }

  @Test
  fun studyFlow_withPrepopulatedDeck_navigatesAndShowsContent() {
    val repo = FirestoreFlashcardsRepoProvider.get()

    runBlocking { com.google.firebase.auth.FirebaseAuth.getInstance().signInAnonymously().await() }

    runBlocking {
      repo.createDeck(
          title = "CI Deck",
          description = "Preloaded",
          cards = listOf(Flashcard(question = "What is binary search?", answer = "O(log n)")))
    }

    composeRule.setContent { EduMonTheme { FlashcardsApp() } }

    val studyMatcher = hasText("Study", substring = true, ignoreCase = true)

    composeRule.waitUntil(10_000) {
      composeRule
          .onAllNodes(studyMatcher, useUnmergedTree = true)
          .fetchSemanticsNodes()
          .isNotEmpty()
    }

    val study = composeRule.onAllNodes(studyMatcher, useUnmergedTree = true)[0]
    study.performClick()

    composeRule.waitAndAssertVisible("Card 1") // matches "Card 1 of 1" etc.
    composeRule.waitAndAssertVisible("Question")
    composeRule.waitAndAssertVisible("reveal answer") // matches "Tap to reveal answer"
  }

  @Test
  fun deleteDialog_shows_onTrashClick_andCallsCallback_onConfirm() {
    val deck =
        Deck(
            id = "deck-1",
            title = "Algebra",
            description = "Basics",
            cards = mutableListOf(Flashcard(question = "Q1", answer = "A1")))

    var deletedId: String? = null

    composeRule.setContent {
      EduMonTheme {
        DeckRow(
            deck = deck,
            onStudyDeck = {},
            onDeleteDeck = { id -> deletedId = id },
            vm = DeckListViewModel(FakeRepositories.flashcardsRepository))
      }
    }

    // Dialog not shown initially
    composeRule.onNodeWithText("Delete deck?").assertDoesNotExist()

    // Click trash icon
    composeRule.onNodeWithContentDescription("Delete deck").performClick()

    // Dialog appears
    composeRule.onNodeWithText("Delete deck?").assertIsDisplayed()
    composeRule.onNodeWithText("This will permanently remove “${deck.title}”.").assertIsDisplayed()

    // Cancel -> dialog closes, callback not called
    composeRule.onNodeWithText("Cancel").performClick()
    composeRule.onNodeWithText("Delete deck?").assertDoesNotExist()
    assert(deletedId == null)

    // Open again
    composeRule.onNodeWithContentDescription("Delete deck").performClick()

    // Confirm delete
    composeRule.onNodeWithText("Delete").performClick()

    assert(deletedId == deck.id)

    composeRule.onNodeWithText("Delete deck?").assertDoesNotExist()
  }

  @Test
  fun navigate_to_createDeck() {
    composeRule.setContent { EduMonTheme { FlashcardsApp() } }

    composeRule.onNodeWithTag("CreateDeckButton").performClick()

    composeRule.onNodeWithTag("CreateDeckScreenRoot").assertIsDisplayed()
  }

  @Test
  fun navigate_to_importDeck() {
    composeRule.setContent { EduMonTheme { FlashcardsApp() } }

    composeRule.onNodeWithTag("ImportDeckFab").performClick()

    composeRule.onNodeWithTag("ImportDeckScreenRoot").assertIsDisplayed()
  }
}
