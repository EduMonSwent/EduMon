package com.android.sample.ui.flashcards

import com.android.sample.data.Priority
import com.android.sample.data.Status
import com.android.sample.data.ToDo
import com.android.sample.repositories.ToDoRepository
import com.android.sample.ui.flashcards.data.FlashcardsRepository
import com.android.sample.ui.flashcards.model.Confidence
import com.android.sample.ui.flashcards.model.Deck
import com.android.sample.ui.flashcards.model.Flashcard
import java.util.UUID
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.test.*
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

// Some parts of this code have been generated by AI
/* ---------- Fakes used by the tests ---------- */

private class FakeFlashcardsRepository : FlashcardsRepository {
  private val _decks = MutableStateFlow<List<Deck>>(emptyList())

  override fun observeDecks(): Flow<List<Deck>> = _decks

  override fun observeDeck(deckId: String): Flow<Deck?> =
      _decks.map { it.firstOrNull { d -> d.id == deckId } }

  override suspend fun createDeck(
      title: String,
      description: String,
      cards: List<Flashcard>
  ): String {
    val id = UUID.randomUUID().toString()
    val deck =
        Deck(
            id = id,
            title = title.ifBlank { "New deck" },
            description = description,
            cards = cards.toMutableList())
    _decks.value = _decks.value + deck
    return id
  }

  override suspend fun addCard(deckId: String, card: Flashcard) {
    _decks.value =
        _decks.value.map { d ->
          if (d.id == deckId) d.copy(cards = (d.cards + card).toMutableList()) else d
        }
  }

  override suspend fun deleteDeck(deckId: String) {
    _decks.value = _decks.value.filterNot { it.id == deckId }
  }
}

private class FakeToDoRepo : ToDoRepository {
  val added = mutableListOf<ToDo>()
  private val _todos = MutableStateFlow<List<ToDo>>(emptyList())
  override val todos: Flow<List<ToDo>> = _todos

  override suspend fun add(todo: ToDo) {
    added += todo
    _todos.value = _todos.value + todo
  }

  override suspend fun update(todo: ToDo) {
    _todos.value = _todos.value.map { if (it.id == todo.id) todo else it }
  }

  override suspend fun remove(id: String) {
    _todos.value = _todos.value.filter { it.id != id }
  }

  override suspend fun getById(id: String): ToDo? = _todos.value.firstOrNull { it.id == id }
}

/* ---------- Tests ---------- */

@OptIn(ExperimentalCoroutinesApi::class)
class FlashcardsViewModelsTest {

  private val dispatcher = StandardTestDispatcher()

  @Before
  fun setUp() {
    Dispatchers.setMain(dispatcher)
  }

  @After
  fun tearDown() {
    Dispatchers.resetMain()
  }

  @Test
  fun deckListViewModel_exposesDecks_andReflectsRepoChanges() = runTest {
    val fakeRepo = FakeFlashcardsRepository()
    val vm = DeckListViewModel(repo = fakeRepo)

    val initialCount = vm.decks.first().size

    val newId =
        fakeRepo.createDeck(
            title = "DeckListVM Deck",
            description = "desc",
            cards = listOf(Flashcard(question = "Q", answer = "A")))
    advanceUntilIdle()

    val after = vm.decks.first()
    assertEquals(initialCount + 1, after.size)
    assertTrue(after.any { it.id == newId && it.title == "DeckListVM Deck" })

    vm.deleteDeck(newId)
    advanceUntilIdle()

    val afterDelete = vm.decks.first()
    assertEquals(initialCount, afterDelete.size)
    assertFalse(afterDelete.any { it.id == newId })
  }

  @Test
  fun createDeckViewModel_fullFlow_addUpdateRemove_save_addsDeck() = runTest {
    val fakeRepo = FakeFlashcardsRepository()
    val fakeToDo = FakeToDoRepo()
    val vm = CreateDeckViewModel(fakeToDo, fakeRepo)

    // initial state
    assertEquals("", vm.title.value)
    assertEquals("", vm.description.value)
    assertTrue(vm.cards.value.isEmpty())

    // edit
    vm.setTitle("Algebra")
    vm.setDescription("Basics")
    vm.addEmptyCard()
    vm.addEmptyCard()
    vm.updateCard(0, question = "What is a vector?", answer = "Magnitude and direction.")
    vm.updateCard(1, question = "Matrix determinant?", answer = "Volume scale / invertibility.")
    vm.removeCard(1)

    var savedId: String? = null
    vm.save { savedId = it }
    advanceUntilIdle()

    val decks = fakeRepo.observeDecks().first()
    val saved = decks.first { it.id == savedId }
    assertEquals("Algebra", saved.title)
    assertEquals("Basics", saved.description)
    assertEquals(1, saved.cards.size)
    assertEquals("What is a vector?", saved.cards.first().question)
    assertEquals("Magnitude and direction.", saved.cards.first().answer)
  }

  @Test
  fun studyViewModel_flip_next_prev_record_updatesState() =
      runTest(UnconfinedTestDispatcher()) {
        val fakeRepo = FakeFlashcardsRepository()
        val deckId =
            fakeRepo.createDeck(
                title = "Study Deck",
                description = "d",
                cards =
                    listOf(
                        Flashcard(question = "Q1", answer = "A1"),
                        Flashcard(question = "Q2", answer = "A2"),
                        Flashcard(question = "Q3", answer = "A3"),
                    ))

        val vm = StudyViewModel(deckId = deckId, repo = fakeRepo)

        advanceUntilIdle()

        var s = vm.state.value
        assertEquals(3, s.total)
        assertEquals("Q1", s.currentOrNull?.question)
        assertTrue(s.isFirst)
        assertFalse(s.isLast)
        assertFalse(s.showingAnswer)

        vm.flip()
        s = vm.state.value
        assertTrue(s.showingAnswer)

        vm.record(Confidence.MEDIUM)
        s = vm.state.value
        assertEquals(1, s.index)
        assertEquals("Q2", s.currentOrNull?.question)
        assertFalse(s.showingAnswer)

        vm.next()
        s = vm.state.value
        assertEquals(2, s.index)
        assertTrue(s.isLast)

        vm.next() // stay at end
        s = vm.state.value
        assertEquals(2, s.index)

        vm.prev()
        s = vm.state.value
        assertEquals(1, s.index)
        assertFalse(s.isFirst)
        assertFalse(s.isLast)
      }

  @Test
  fun createDeck_save_createsTodoLinkedToDeck() = runTest {
    val fakeToDo = FakeToDoRepo()
    val vm = CreateDeckViewModel(toDoRepo = fakeToDo, repo = FakeFlashcardsRepository())

    vm.setTitle("Biology Ch.1")
    vm.setDescription("Cells & organelles")
    vm.addEmptyCard()
    vm.updateCard(0, question = "Cell unit?", answer = "Basic unit of life")

    var deckId: String? = null
    vm.save { deckId = it }
    advanceUntilIdle()

    val todo = fakeToDo.added.single()
    assertEquals("Study: Biology Ch.1", todo.title)
    assertEquals(Priority.MEDIUM, todo.priority)
    assertEquals(Status.TODO, todo.status)
    assertEquals("Cells & organelles", todo.note)
    assertEquals(1, todo.links.size)
    assertTrue(todo.links[0].startsWith("flashcard://deck/"))
    assertTrue(todo.links[0].endsWith(deckId!!))
  }

  @Test
  fun createDeck_save_withBlankTitle_usesFallbackTodoTitle() = runTest {
    val fakeToDo = FakeToDoRepo()
    val vm = CreateDeckViewModel(toDoRepo = fakeToDo, repo = FakeFlashcardsRepository())

    vm.setTitle("") // blank => fallback "New deck"
    vm.setDescription("")
    vm.addEmptyCard()
    vm.updateCard(0, question = "Q", answer = "A")

    vm.save {}
    advanceUntilIdle()

    val todo = fakeToDo.added.single()
    assertEquals("Study: New deck", todo.title)
  }
}
