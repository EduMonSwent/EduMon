package com.android.sample.ui.games

import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Book
import androidx.compose.material.icons.filled.School
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.compose.ui.test.onAllNodesWithText
import androidx.compose.ui.test.onNodeWithText
import androidx.compose.ui.test.performClick
import org.junit.Rule
import org.junit.Test

// Parts of this code have been generated by an LLM
class MemoryGameScreenExtendedTest {

  @get:Rule val composeRule = createComposeRule()

  /**
   * Covers:
   * - if (flipped.size == 2) { LaunchedEffect(flipped) { delay(700) ... } }
   * - both branches: match and mismatch
   *
   * We avoid relying on unstable grid indexing by using a deterministic initialCards list where we
   * control the icon pairs and IDs.
   */
  @Test
  fun matchingLogic_executes_match_and_mismatch_paths() {
    // 3x3 grid expects 18 cards (9 pairs).
    // We create a deterministic deck:
    // - ids 0 & 1 => MATCH (Book)
    // - ids 2 & 3 => MISMATCH (Book vs School)
    // - rest filler pairs (all Book) just to reach 18 cards
    val initialCards =
        listOf(
            MemoryCard(id = 0, icon = Icons.Filled.Book),
            MemoryCard(id = 1, icon = Icons.Filled.Book), // match with 0
            MemoryCard(id = 2, icon = Icons.Filled.Book),
            MemoryCard(id = 3, icon = Icons.Filled.School) // mismatch with 2
            ) + List(14) { i -> MemoryCard(id = 4 + i, icon = Icons.Filled.Book) }

    composeRule.setContent {
      // Timer disabled to keep this test focused/stable
      MemoryGameScreenBase(
          icons = listOf(Icons.Filled.Book, Icons.Filled.School),
          initialCards = initialCards,
          initialWin = false,
          initialGameOver = false,
          enableTimer = false)
    }

    // Flip 0 and 1 => should MATCH, score += 10 after 700ms delay
    clickTwoQuestionMarks()
    composeRule.mainClock.autoAdvance = false
    composeRule.mainClock.advanceTimeBy(800L) // > 700ms
    composeRule.waitForIdle()
    composeRule.mainClock.autoAdvance = true

    // Minimal assertion: score text exists and contains 10
    composeRule.onNodeWithText("Score: 10", substring = true).assertExists()

    // Flip 2 and 3 => MISMATCH, cards get unflipped after 700ms
    clickTwoQuestionMarks()
    composeRule.mainClock.autoAdvance = false
    composeRule.mainClock.advanceTimeBy(800L)
    composeRule.waitForIdle()
    composeRule.mainClock.autoAdvance = true

    // Minimal check: game is still running (no overlay); "Restart" should not exist
    composeRule.onAllNodesWithText("Restart").apply { /* empty */}
  }

  /**
   * Covers the timer loop:
   * - LaunchedEffect(enableTimer, isGameOver, isWin) { while(timer>0){delay(1000);timer--} ... }
   *
   * We use MemoryGameScreenBase directly so enableTimer=true. Then we fast-forward Compose test
   * clock by 90 seconds to trigger game over.
   */
  @Test
  fun timerLoop_executes_and_setsGameOver_whenTimeRunsOut() {
    // Any 18 cards is fine; keep it deterministic.
    val initialCards = List(18) { i -> MemoryCard(id = i, icon = Icons.Filled.Book) }

    composeRule.setContent {
      MemoryGameScreenBase(
          icons = listOf(Icons.Filled.Book, Icons.Filled.School),
          initialCards = initialCards,
          initialWin = false,
          initialGameOver = false,
          enableTimer = true)
    }

    // Freeze and fast-forward time: 90 ticks * 1000ms
    composeRule.mainClock.autoAdvance = false
    composeRule.mainClock.advanceTimeBy(90_000L)
    composeRule.waitForIdle()
    composeRule.mainClock.autoAdvance = true

    // Minimal assertion: overlay appears ("Time’s up!")
    composeRule.onNodeWithText("Time’s up!", substring = true).assertExists()
  }

  /**
   * Tiny smoke test to execute MemoryGameScreenTestable default initialCards=generateCards(...)
   * (covers those default parameter lines).
   */
  @Test
  fun testableComposable_defaults_execute_generateCards_path() {
    composeRule.setContent { MemoryGameScreenTestable() }
    composeRule.onNodeWithText("Memory Game").assertExists()
  }

  // -----------------------
  // Helpers
  // -----------------------

  /**
   * Clicks two currently-visible "?" nodes (the face-down cards). This is more stable than indexing
   * cards after the first click.
   */
  private fun clickTwoQuestionMarks() {
    val q = composeRule.onAllNodesWithText("?")
    q[0].performClick()
    // after first click, one "?" disappears; re-query then click first remaining
    composeRule.waitForIdle()
    composeRule.onAllNodesWithText("?")[0].performClick()
    composeRule.waitForIdle()
  }
}
