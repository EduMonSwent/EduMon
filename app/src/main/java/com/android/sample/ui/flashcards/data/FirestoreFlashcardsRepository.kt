package com.android.sample.ui.flashcards.data

import com.android.sample.core.helpers.DefaultDispatcherProvider
import com.android.sample.core.helpers.DispatcherProvider
import com.android.sample.ui.flashcards.model.Deck
import com.android.sample.ui.flashcards.model.Flashcard
import com.google.android.gms.tasks.Tasks
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.*
import java.util.UUID
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/**
 * Firestore implementation aligned with models: Deck(id, title, description, createdAt: Long,
 * cards: List<Flashcard>) Flashcard(id, question, answer)
 *
 * Firestore schema: users/{uid}/decks/{deckId} -> { id, title, description, createdAtMillis,
 * updatedAt } users/{uid}/decks/{deckId}/cards/{cardId} -> { id, q, a, createdAt, updatedAt } Some
 * parts of this code have been generated by AI.
 */
class FirestoreFlashcardsRepository(
    private val db: FirebaseFirestore,
    private val auth: FirebaseAuth,
    private val dispatchers: DispatcherProvider = DefaultDispatcherProvider,
) : FlashcardsRepository {

  // helpers
  private fun isSignedIn(): Boolean = auth.currentUser != null

  private fun decksCol(): CollectionReference {
    val uid =
        auth.currentUser?.uid
            ?: throw IllegalStateException("User must be signed in to access flashcards")
    return db.collection("users").document(uid).collection("decks")
  }

  private fun deckDoc(deckId: String) = decksCol().document(deckId)

  private fun cardsCol(deckId: String) = deckDoc(deckId).collection("cards")

  // Firestore DTOs
  private data class DeckFs(
      val title: String = "",
      val description: String = "",
      val createdAtMillis: Long? = null,
      val shareable: Boolean = false
  )

  private data class CardFs(val q: String = "", val a: String = "")

  private fun DocumentSnapshot.toDeckFs(): DeckFs =
      DeckFs(
          title = getString("title") ?: "",
          description = getString("description") ?: "",
          createdAtMillis = getLong("createdAtMillis"),
          shareable = getBoolean("shareable") ?: false)

  private fun DocumentSnapshot.toCardFs(): CardFs =
      CardFs(q = getString("q") ?: "", a = getString("a") ?: "")

  private fun deckFrom(id: String, fs: DeckFs, cards: List<Flashcard>): Deck =
      Deck(
          id = id,
          title = fs.title.ifBlank { "New deck" },
          description = fs.description,
          createdAt = fs.createdAtMillis ?: System.currentTimeMillis(),
          cards = cards.toMutableList(),
          shareable = fs.shareable)

  private fun cardFrom(id: String, fs: CardFs): Flashcard =
      Flashcard(id = id, question = fs.q, answer = fs.a)

  // API
  override fun observeDecks(): Flow<List<Deck>> = callbackFlow {
    if (!isSignedIn()) {
      trySend(emptyList())
      awaitClose {}
      return@callbackFlow
    }

    val listener =
        decksCol().addSnapshotListener { decksSnap, error ->
          if (error != null) {
            trySend(emptyList())
            return@addSnapshotListener
          }

          val docs =
              decksSnap?.documents
                  ?: run {
                    trySend(emptyList())
                    return@addSnapshotListener
                  }

          launch(dispatchers.io) {
            val finalList = mutableListOf<Deck>()

            for (doc in docs) {
              try {
                val deckId = doc.id
                val fs = doc.toDeckFs()
                val cardsSnap = Tasks.await(cardsCol(deckId).get())
                val cards = cardsSnap.documents.map { d -> cardFrom(d.id, d.toCardFs()) }
                finalList += deckFrom(deckId, fs, cards)
              } catch (e: Exception) {
                // Skip this deck if there's an error
              }
            }

            trySend(finalList)
          }
        }

    awaitClose { listener.remove() }
  }

  override fun observeDeck(deckId: String): Flow<Deck?> = callbackFlow {
    if (!isSignedIn()) {
      trySend(null)
      awaitClose {}
      return@callbackFlow
    }

    val reg =
        deckDoc(deckId).addSnapshotListener { docSnap, _ ->
          if (docSnap == null || !docSnap.exists()) {
            trySend(null)
            return@addSnapshotListener
          }

          launch(dispatchers.io) {
            val deckFs = docSnap.toDeckFs()
            val cardsSnap = Tasks.await(cardsCol(deckId).get())
            val cards =
                cardsSnap.documents
                    .map { it.id to it.toCardFs() }
                    .map { (id, c) -> cardFrom(id, c) }

            trySend(deckFrom(deckId, deckFs, cards)).isSuccess
          }
        }
    awaitClose { reg.remove() }
  }

  // Mutations
  override suspend fun createDeck(
      title: String,
      description: String,
      cards: List<Flashcard>
  ): String =
      withContext(dispatchers.io) {
        if (!isSignedIn()) {
          // keep contract: still return an id, but perform no remote write
          return@withContext UUID.randomUUID().toString()
        }

        val newId = UUID.randomUUID().toString()
        val deckRef = deckDoc(newId)
        val nowMs = System.currentTimeMillis()

        db.runBatch { b ->
              val deckData =
                  hashMapOf(
                      "id" to newId,
                      "title" to title.ifBlank { "New deck" },
                      "description" to description,
                      "createdAtMillis" to nowMs,
                      "updatedAt" to FieldValue.serverTimestamp(),
                      "shareable" to false)
              b.set(deckRef, deckData, SetOptions.merge())

              cards
                  .filter { it.question.isNotBlank() && it.answer.isNotBlank() }
                  .forEach { c ->
                    val cardId = c.id.ifEmpty { UUID.randomUUID().toString() }
                    val cardRef = cardsCol(newId).document(cardId)
                    b.set(
                        cardRef,
                        hashMapOf(
                            "id" to cardId,
                            "q" to c.question,
                            "a" to c.answer,
                            "createdAt" to FieldValue.serverTimestamp(),
                            "updatedAt" to FieldValue.serverTimestamp(),
                        ),
                        SetOptions.merge())
                  }
            }
            .let { Tasks.await(it) }

        newId
      }

  override suspend fun addCard(deckId: String, card: Flashcard) =
      withContext(dispatchers.io) {
        if (!isSignedIn()) return@withContext
        if (card.question.isBlank() || card.answer.isBlank()) return@withContext

        val cardId = card.id.ifEmpty { UUID.randomUUID().toString() }

        Tasks.await(
            cardsCol(deckId)
                .document(cardId)
                .set(
                    mapOf(
                        "id" to cardId,
                        "q" to card.question,
                        "a" to card.answer,
                        "createdAt" to FieldValue.serverTimestamp(),
                        "updatedAt" to FieldValue.serverTimestamp(),
                    ),
                    SetOptions.merge()))

        Tasks.await(deckDoc(deckId).update("updatedAt", FieldValue.serverTimestamp()))
      }

  override suspend fun deleteDeck(deckId: String) =
      withContext(dispatchers.io) {
        if (!isSignedIn()) return@withContext
        suspend fun deleteCardsBatchOnce(): Int {
          val snap = Tasks.await(cardsCol(deckId).limit(400).get())
          if (snap.isEmpty) return 0
          val batch = db.batch()
          snap.documents.forEach { batch.delete(it.reference) }
          Tasks.await(batch.commit())
          return snap.size()
        }

        while (deleteCardsBatchOnce() > 0) {
          /* keep deleting */
        }
        Tasks.await(deckDoc(deckId).delete())
      }

  // Toggle shareable flag
  suspend fun setDeckShareable(deckId: String, shareable: Boolean) =
      withContext(dispatchers.io) {
        if (!isSignedIn()) return@withContext
        Tasks.await(deckDoc(deckId).update("shareable", shareable))
      }

  // Create a share token (like "SHR_89smfw32")
  suspend fun createShareToken(deckId: String): String =
      withContext(dispatchers.io) {
        if (!isSignedIn()) return@withContext ""

        val token = UUID.randomUUID().toString()

        val data =
            mapOf(
                "ownerId" to auth.currentUser!!.uid,
                "deckId" to deckId,
                "createdAt" to FieldValue.serverTimestamp())

        Tasks.await(db.collection("sharedDecks").document(token).set(data))

        return@withContext token
      }

  // --------------------------
  // IMPORT SHARED DECK
  // --------------------------
  override suspend fun importSharedDeck(token: String): String =
      withContext(dispatchers.io) {
        if (!isSignedIn()) {
          return@withContext ""
        }

        // 1. Lookup shared token
        val sharedRef = db.collection("sharedDecks").document(token)
        val sharedSnap = Tasks.await(sharedRef.get())

        if (!sharedSnap.exists()) {
          return@withContext ""
        }

        val ownerId = sharedSnap.getString("ownerId") ?: return@withContext ""
        val deckId = sharedSnap.getString("deckId") ?: return@withContext ""

        // 2. Read original deck
        val ownerDeckRef =
            db.collection("users").document(ownerId).collection("decks").document(deckId)

        val deckSnap = Tasks.await(ownerDeckRef.get())
        if (!deckSnap.exists()) {
          return@withContext ""
        }

        val deckFs = deckSnap.data ?: return@withContext ""

        // 3. Read owner's cards
        val cardsSnap = Tasks.await(ownerDeckRef.collection("cards").get())

        // 4. Create new deck for current user
        val newDeckId = UUID.randomUUID().toString()
        val newDeckRef = deckDoc(newDeckId)

        val batchTask =
            db.runBatch { batch ->
              // Copy deck
              val deckData =
                  deckFs.toMutableMap().apply {
                    this["id"] = newDeckId
                    this["shareable"] = false
                    this["createdAtMillis"] = System.currentTimeMillis()
                    this["updatedAt"] = FieldValue.serverTimestamp()
                  }
              batch.set(newDeckRef, deckData)

              // Copy each card with corrected IDs
              for (cardDoc in cardsSnap.documents) {
                val newCardId = UUID.randomUUID().toString()
                val c = cardDoc.data?.toMutableMap() ?: continue

                // Update the ID to match the new document
                c["id"] = newCardId
                c["createdAt"] = FieldValue.serverTimestamp()
                c["updatedAt"] = FieldValue.serverTimestamp()

                val newCardRef = newDeckRef.collection("cards").document(newCardId)
                batch.set(newCardRef, c)
              }
            }

        // Wait for the batch to complete
        Tasks.await(batchTask)

        return@withContext newDeckId
      }
}
