package com.android.sample.ui.flashcards.data

import com.android.sample.ui.flashcards.model.Deck
import com.android.sample.ui.flashcards.model.Flashcard
import java.lang.reflect.Field
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Assert.*
import org.junit.Test

// Some parts of this code have been generated by an AI.
class InMemoryFlashcardsRepositoryTest {

  /** Reset the repository after each test so they don't interfere with each other. */
  @After
  fun tearDown() {
    val decksField: Field = InMemoryFlashcardsRepository::class.java.getDeclaredField("_decks")
    decksField.isAccessible = true
    decksField.set(InMemoryFlashcardsRepository, MutableStateFlow<List<Deck>>(emptyList()))
  }

  @Test
  fun deck_returns_correct_deck_when_ID_exists() = runTest {
    // Arrange
    val deckId = InMemoryFlashcardsRepository.createDeck("Science", "Biology", emptyList())

    // Act
    val foundDeck = InMemoryFlashcardsRepository.deck(deckId)

    // Assert
    assertNotNull(foundDeck)
    assertEquals(deckId, foundDeck!!.id)
    assertEquals("Science", foundDeck.title)
  }

  @Test
  fun deck_returns_null_when_ID_does_not_exist() = runTest {
    // Arrange
    InMemoryFlashcardsRepository.createDeck("History", "WW2", emptyList())

    // Act
    val foundDeck = InMemoryFlashcardsRepository.deck("non-existent-id")

    // Assert
    assertNull(foundDeck)
  }

  @Test
  fun addCard_successfully_adds_a_card_to_the_specified_deck() = runTest {
    // Arrange
    val initialCard = Flashcard(id = "card-101", question = "Q1", answer = "A1")
    val deckId = InMemoryFlashcardsRepository.createDeck("Math", "Algebra", listOf(initialCard))

    // Act
    val newCard = Flashcard(id = "card-102", question = "Q2", answer = "A2")
    InMemoryFlashcardsRepository.addCard(deckId, newCard)
    val updatedDeck = InMemoryFlashcardsRepository.deck(deckId)

    // Assert
    assertNotNull(updatedDeck)
    assertEquals(2, updatedDeck!!.cards.size)
    assertEquals(initialCard, updatedDeck.cards[0])
    assertEquals(newCard, updatedDeck.cards[1])
  }

  @Test
  fun addCard_does_not_change_anything_if_deck_ID_is_invalid() = runTest {
    // Arrange
    val deckId = InMemoryFlashcardsRepository.createDeck("Geography", "Countries", emptyList())
    val initialDecksState = InMemoryFlashcardsRepository.decks.value.toList()

    // Act
    InMemoryFlashcardsRepository.addCard(
        "invalid-id", Flashcard(id = "card-temp", question = "Question", answer = "Answer"))
    val finalDecksState = InMemoryFlashcardsRepository.decks.value.toList()

    // Assert
    assertEquals(initialDecksState, finalDecksState)
    assertTrue(InMemoryFlashcardsRepository.deck(deckId)!!.cards.isEmpty())
  }

  @Test
  fun observeDecks_emits_current_decks_and_reflects_add_and_delete() = runTest {
    // Initially empty
    val initial = InMemoryFlashcardsRepository.observeDecks().first()
    assertTrue(initial.isEmpty())

    // Add two decks
    val deckId1 = InMemoryFlashcardsRepository.createDeck("Deck 1", "Desc 1", emptyList())
    val deckId2 =
        InMemoryFlashcardsRepository.createDeck(
            "Deck 2", "Desc 2", listOf(Flashcard(id = "c1", question = "Q", answer = "A")))

    val afterCreate = InMemoryFlashcardsRepository.observeDecks().first()
    assertEquals(2, afterCreate.size)
    assertTrue(afterCreate.any { it.id == deckId1 })
    assertTrue(afterCreate.any { it.id == deckId2 })

    // Delete one deck
    InMemoryFlashcardsRepository.deleteDeck(deckId1)

    val afterDelete = InMemoryFlashcardsRepository.observeDecks().first()
    assertEquals(1, afterDelete.size)
    assertFalse(afterDelete.any { it.id == deckId1 })
    assertTrue(afterDelete.any { it.id == deckId2 })
  }

  @Test
  fun observeDeck_emits_deck_and_then_null_after_deletion() = runTest {
    // Arrange: create a deck
    val deckId =
        InMemoryFlashcardsRepository.createDeck(
            "Single Deck", "Only one", listOf(Flashcard(id = "c1", question = "Q1", answer = "A1")))

    // First emission: deck exists
    val deckBeforeDelete = InMemoryFlashcardsRepository.observeDeck(deckId).first()
    assertNotNull(deckBeforeDelete)
    assertEquals(deckId, deckBeforeDelete!!.id)
    assertEquals("Single Deck", deckBeforeDelete.title)

    // Act: delete the deck
    InMemoryFlashcardsRepository.deleteDeck(deckId)

    // After delete: observeDeck should emit null for that id
    val deckAfterDelete = InMemoryFlashcardsRepository.observeDeck(deckId).first()
    assertNull(deckAfterDelete)
  }

  @Test
  fun deleteDeck_removes_only_the_specified_deck() = runTest {
    // Arrange: two decks
    val deckId1 = InMemoryFlashcardsRepository.createDeck("To Delete", "Temp", emptyList())
    val deckId2 = InMemoryFlashcardsRepository.createDeck("To Keep", "Important", emptyList())

    // Sanity: both exist
    assertNotNull(InMemoryFlashcardsRepository.deck(deckId1))
    assertNotNull(InMemoryFlashcardsRepository.deck(deckId2))

    // Act: delete the first deck
    InMemoryFlashcardsRepository.deleteDeck(deckId1)

    // Assert: first deck gone, second still present
    assertNull(InMemoryFlashcardsRepository.deck(deckId1))
    assertNotNull(InMemoryFlashcardsRepository.deck(deckId2))

    val allDecks = InMemoryFlashcardsRepository.observeDecks().first()
    assertFalse(allDecks.any { it.id == deckId1 })
    assertTrue(allDecks.any { it.id == deckId2 })
  }

  @Test
  fun importSharedDeck_alwaysReturnsEmptyString() = runTest {
    val result = InMemoryFlashcardsRepository.importSharedDeck("any-token")
    assertEquals("", result)
  }
}
